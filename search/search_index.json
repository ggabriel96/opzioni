{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"opzioni \u00b6 opzioni is a command line arguments parser library for C++. Goals \u00b6 The goals of this library, in order of importance, are: Be as simple and enjoyable as possible. This mainly targets the user of the library, but also includes the user of the command line tool built with it. constexpr -all-the-things. Most of the time, all the information needed to build a command line interface is available at compile-time, so we should take advantage of that. If it compiles, it works. That's utopic, but that's what is being strived for. It's also very closely related to the previous goal. We should be able to detect most errors at compile-time and provide decent diagnostics. Try not to repeat yourself. When specifying a CLI, if some information was already given to the library, that same information should not be needed again. For example, if the type of an argument was already specified, the user should not be asked to tell the type again. Unfortunately that is very hard, so some places still require duplicate information. Be bleeding-edge. This library requires C++20. That limits a lot its potential users, but also allows for the use of the new and powerful features of C++. It also helps to accomplish the previous goals. Disclaimer \u00b6 This is a personal project with no promise of maintainability for the time being. I started it to learn more about C++ and its new features. Although it is not in early development, since I'm working on it for months and iterated over it many times, it is not stable or production-ready . There are many unit tests missing . I frequently changed the interface of the library and I'm not afraid of changing it radically again if I think it would improve the UX. Another example is the names of the namespaces and what is in them. There is a lot of polish and optimization work to do. There is a whole documentation to write. Sneak peek \u00b6 The code below is a fully working example, taken from examples/hello.cpp , only reformatted and with quotes changed to angle brackets in the #include . Feel free to take a look at the other, more complex, examples in the same directory. #include <iostream> #include <string_view> #include <opzioni.hpp> int main ( int argc , char const * argv []) { using namespace opzioni ; constexpr auto hello = Program ( \"hello\" ). version ( \"0.1\" ). intro ( \"Greeting people since the dawn of computing\" ) + Pos ( \"name\" ). help ( \"Your name please, so I can greet you\" ) * Help () * Version (); auto const args = hello ( argc , argv ); std :: string_view const name = args [ \"name\" ]; std :: cout << \"Hello, \" << name << \"! \\n \" ; } That gives us: Automatic help with --help or -h $ ./build/examples/hello -h hello 0.1 Greeting people since the dawn of computing Usage: hello <name> [--help] [--version] Positionals: name Your name please, so I can greet you Options & Flags: -h, --help Display this information -V, --version Display the software version Automatic version with --version or -V $ ./build/examples/hello -V hello 0.1 Automatic error handling $ ./build/examples/hello Gabriel Galli Unexpected positional argument `Galli`. This program expects 1 positional arguments Usage: hello <name> [--help] [--version] And finally: $ ./build/examples/hello \"Gabriel Galli\" Hello, Gabriel Galli! License \u00b6 opzioni's license is the Boost Software License (BSL) 1.0 . This means you are free to use this library as you wish and see fit. It is only needed to provide a copy of the license if the source is also being distributed. In other words, there is no need to bundle opzioni's license with your binary . Acknowledgements \u00b6 Thank you to JetBrains for supporting this project by providing free access to its products as part of the Open Source Licenses program.","title":"Home"},{"location":"#opzioni","text":"opzioni is a command line arguments parser library for C++.","title":"opzioni"},{"location":"#goals","text":"The goals of this library, in order of importance, are: Be as simple and enjoyable as possible. This mainly targets the user of the library, but also includes the user of the command line tool built with it. constexpr -all-the-things. Most of the time, all the information needed to build a command line interface is available at compile-time, so we should take advantage of that. If it compiles, it works. That's utopic, but that's what is being strived for. It's also very closely related to the previous goal. We should be able to detect most errors at compile-time and provide decent diagnostics. Try not to repeat yourself. When specifying a CLI, if some information was already given to the library, that same information should not be needed again. For example, if the type of an argument was already specified, the user should not be asked to tell the type again. Unfortunately that is very hard, so some places still require duplicate information. Be bleeding-edge. This library requires C++20. That limits a lot its potential users, but also allows for the use of the new and powerful features of C++. It also helps to accomplish the previous goals.","title":"Goals"},{"location":"#disclaimer","text":"This is a personal project with no promise of maintainability for the time being. I started it to learn more about C++ and its new features. Although it is not in early development, since I'm working on it for months and iterated over it many times, it is not stable or production-ready . There are many unit tests missing . I frequently changed the interface of the library and I'm not afraid of changing it radically again if I think it would improve the UX. Another example is the names of the namespaces and what is in them. There is a lot of polish and optimization work to do. There is a whole documentation to write.","title":"Disclaimer"},{"location":"#sneak-peek","text":"The code below is a fully working example, taken from examples/hello.cpp , only reformatted and with quotes changed to angle brackets in the #include . Feel free to take a look at the other, more complex, examples in the same directory. #include <iostream> #include <string_view> #include <opzioni.hpp> int main ( int argc , char const * argv []) { using namespace opzioni ; constexpr auto hello = Program ( \"hello\" ). version ( \"0.1\" ). intro ( \"Greeting people since the dawn of computing\" ) + Pos ( \"name\" ). help ( \"Your name please, so I can greet you\" ) * Help () * Version (); auto const args = hello ( argc , argv ); std :: string_view const name = args [ \"name\" ]; std :: cout << \"Hello, \" << name << \"! \\n \" ; } That gives us: Automatic help with --help or -h $ ./build/examples/hello -h hello 0.1 Greeting people since the dawn of computing Usage: hello <name> [--help] [--version] Positionals: name Your name please, so I can greet you Options & Flags: -h, --help Display this information -V, --version Display the software version Automatic version with --version or -V $ ./build/examples/hello -V hello 0.1 Automatic error handling $ ./build/examples/hello Gabriel Galli Unexpected positional argument `Galli`. This program expects 1 positional arguments Usage: hello <name> [--help] [--version] And finally: $ ./build/examples/hello \"Gabriel Galli\" Hello, Gabriel Galli!","title":"Sneak peek"},{"location":"#license","text":"opzioni's license is the Boost Software License (BSL) 1.0 . This means you are free to use this library as you wish and see fit. It is only needed to provide a copy of the license if the source is also being distributed. In other words, there is no need to bundle opzioni's license with your binary .","title":"License"},{"location":"#acknowledgements","text":"Thank you to JetBrains for supporting this project by providing free access to its products as part of the Open Source Licenses program.","title":"Acknowledgements"},{"location":"user-guide/customizing-programs/","text":"Customizing programs \u00b6 The following sections explain the various attributes of Program and how to set them via the provided member functions. In code, however, they are not member variables of Program (that's why I called them attributes instead). They are actually member variables of the ProgramMetadata class, held in the metadata member variable of Program . This detail deserves a longer explanation somewhere else, so to keep things short here, it suffices to say that it serves the purpose of having a common data structure between Program and ProgramView . ProgramView is like a std::string_view , but for Program , and all program data is accessible through it, including its arguments and commands. name \u00b6 The first and most basic information of Program is name . It is the only attribute that the user is required to provide. Thus, it is specified in the constructor: constexpr auto wget = Program ( \"wget\" ); It is used, for example, when printing the automatic help text, and as identifier when adding a program as command of another program. Output of the snippet above 1 : wget Usage: wget [--help] Options & Flags: -h, --help Display this information title \u00b6 The title is like the headline of the program. It is optional, but is also given in the constructor, as the second argument: constexpr auto wget = Program ( \"wget\" , \"a non-interactive network retriever\" ); There is currently no special use for it, so it is only informational. Output of the snippet above: wget - a non-interactive network retriever Usage: wget [--help] Options & Flags: -h, --help Display this information version \u00b6 version is... well, the program version. It is specified via the version member function and can be any string. constexpr auto wget = Program ( \"wget\" , \"a non-interactive network retriever\" ) . version ( \"1.20.3\" ); In the automatic help, it is printed right next to the program name in the title line, so it is best to keep it within a maximum of ~16 characters. Output of the snippet above: wget 1.20.3 - a non-interactive network retriever Usage: wget [--help] Options & Flags: -h, --help Display this information introduction \u00b6 introduction is what goes between the program name and its list of arguments. So, for example, it can be used as an actual introduction to the program and what it does, or some message about its usage. It is specified via the intro member function. It has a special purpose, though. The introduction is used as the description for commands in the automatic help text of their parent program. In that case, an actual introduction is recommended. So an introduction like the one in the example below is OK if the program is the root program. It's also best to keep it short (2 or 3 lines maximum). constexpr auto wget = Program ( \"wget\" , \"a non-interactive network retriever\" ) . version ( \"1.20.3\" ) . intro ( \"Mandatory arguments to long options are mandatory for short options too.\" ); Output of the snippet above: wget 1.20.3 - a non-interactive network retriever Mandatory arguments to long options are mandatory for short options too. Usage: wget [--help] Options & Flags: -h, --help Display this information details \u00b6 details is a piece of text that goes after the list of arguments. It can be used, for example, to add some details that weren't relevant before, like website, documentation, or contact information. It is specified via the details member function. constexpr auto wget = Program ( \"wget\" , \"a non-interactive network retriever\" ) . version ( \"1.20.3\" ) . intro ( \"Mandatory arguments to long options are mandatory for short options too.\" ) . details ( \"Email bug reports, questions, discussions to <bug-wget@gnu.org>\" \" and/or open issues at https://savannah.gnu.org/bugs/?func=additem&group=wget.\" ); Note that C++ allows strings to be break into separate pieces for better code formatting, but that does not affect the output of the automatic help. Don't make it too long, though, as that will move the argument list up in the help text. Output of the snippet above: wget 1.20.3 - a non-interactive network retriever Mandatory arguments to long options are mandatory for short options too. Usage: wget [--help] Options & Flags: -h, --help Display this information Email bug reports, questions, discussions to <bug-wget@gnu.org> and/or open issues at https://savannah.gnu.org/bugs/?func=additem&group=wget. msg_width \u00b6 The msg_width is what determines the maximum width of the messages that opzioni will output related to the program. For example, it is used when printing the automatic help and when using the built-in error handling actions. The default is 100 and it can be changed via the msg_width member function. constexpr auto wget = Program ( \"wget\" , \"a non-interactive network retriever\" ) . version ( \"1.20.3\" ) . intro ( \"Mandatory arguments to long options are mandatory for short options too.\" ) . details ( \"Email bug reports, questions, discussions to <bug-wget@gnu.org>\" \" and/or open issues at https://savannah.gnu.org/bugs/?func=additem&group=wget.\" ) . msg_width ( 64 ); Output of the snippet above: wget 1.20.3 - a non-interactive network retriever Mandatory arguments to long options are mandatory for short options too. Usage: wget [--help] Options & Flags: -h, --help Display this information Email bug reports, questions, discussions to <bug-wget@gnu.org> and/or open issues at https://savannah.gnu.org/bugs/?func=additem&group=wget. It is a best-effort, though, so don't make it too narrow. If the maximum width is not enough for long words (like the URL above), they will be printed in a dedicated line anyway (try this last snippet with a maximum width of 32). error_handler \u00b6 error_handler determines how the program behaves when a user error occurs. This doesn't affect the automatic help text. The default is to print the error message and the usage of the program. Changing it is done via the on_error member function. For example, to only print the error message: constexpr auto wget = Program ( \"wget\" , \"a non-interactive network retriever\" ) . version ( \"1.20.3\" ) . intro ( \"Mandatory arguments to long options are mandatory for short options too.\" ) . details ( \"Email bug reports, questions, discussions to <bug-wget@gnu.org>\" \" and/or open issues at https://savannah.gnu.org/bugs/?func=additem&group=wget.\" ) . msg_width ( 64 ) . on_error ( print_error ); This also deserves a longer documentation, but until that's available, here is a brief explanation: The argument to on_error must be of the ErrorHandler type, which is actually a using declaration for the following function pointer: using ErrorHandler = int ( * )( ProgramView const , UserError const & ); ProgramView was introduced earlier . UserError is the base class of the exceptions that are thrown when a user error occurs (user as in user of the command-line program). All opzioni exceptions inherit from std::exception , so the error message can be obtained via their what member function. Currently, the built-in error handlers are: print_error : print the error message only. print_error_and_usage : print the error message and the program usage (the default). rethrow : rethrow the exception. Just a detail about rethrow : note that, given the signature of ErrorHandler , the information of the actual class of the exception that was thrown is lost. In order to preserve their type information (and also be able to granularly catch exceptions, if that's desired), use the parse free function instead of Program 's call operator when parsing the command-line. Just add a try and as many catch es as desired to the following snippet: auto const map = parse ( wget , { argv , argc }); argc and argv are \"flipped\" and within {} because that's constructing a std::span . Calling parse instead of Program::operator() avoids the built-in try... catch (which invokes error_handler ). This means that \"unsetting\" or clearing error_handler isn't needed. In fact, on_error(nullptr) or on_error(NULL) doesn't compile. error_handler is a required attribute of Program . snippet output generated by adding the automatic help to the example. \u21a9","title":"Customizing programs"},{"location":"user-guide/customizing-programs/#customizing-programs","text":"The following sections explain the various attributes of Program and how to set them via the provided member functions. In code, however, they are not member variables of Program (that's why I called them attributes instead). They are actually member variables of the ProgramMetadata class, held in the metadata member variable of Program . This detail deserves a longer explanation somewhere else, so to keep things short here, it suffices to say that it serves the purpose of having a common data structure between Program and ProgramView . ProgramView is like a std::string_view , but for Program , and all program data is accessible through it, including its arguments and commands.","title":"Customizing programs"},{"location":"user-guide/customizing-programs/#name","text":"The first and most basic information of Program is name . It is the only attribute that the user is required to provide. Thus, it is specified in the constructor: constexpr auto wget = Program ( \"wget\" ); It is used, for example, when printing the automatic help text, and as identifier when adding a program as command of another program. Output of the snippet above 1 : wget Usage: wget [--help] Options & Flags: -h, --help Display this information","title":"name"},{"location":"user-guide/customizing-programs/#title","text":"The title is like the headline of the program. It is optional, but is also given in the constructor, as the second argument: constexpr auto wget = Program ( \"wget\" , \"a non-interactive network retriever\" ); There is currently no special use for it, so it is only informational. Output of the snippet above: wget - a non-interactive network retriever Usage: wget [--help] Options & Flags: -h, --help Display this information","title":"title"},{"location":"user-guide/customizing-programs/#version","text":"version is... well, the program version. It is specified via the version member function and can be any string. constexpr auto wget = Program ( \"wget\" , \"a non-interactive network retriever\" ) . version ( \"1.20.3\" ); In the automatic help, it is printed right next to the program name in the title line, so it is best to keep it within a maximum of ~16 characters. Output of the snippet above: wget 1.20.3 - a non-interactive network retriever Usage: wget [--help] Options & Flags: -h, --help Display this information","title":"version"},{"location":"user-guide/customizing-programs/#introduction","text":"introduction is what goes between the program name and its list of arguments. So, for example, it can be used as an actual introduction to the program and what it does, or some message about its usage. It is specified via the intro member function. It has a special purpose, though. The introduction is used as the description for commands in the automatic help text of their parent program. In that case, an actual introduction is recommended. So an introduction like the one in the example below is OK if the program is the root program. It's also best to keep it short (2 or 3 lines maximum). constexpr auto wget = Program ( \"wget\" , \"a non-interactive network retriever\" ) . version ( \"1.20.3\" ) . intro ( \"Mandatory arguments to long options are mandatory for short options too.\" ); Output of the snippet above: wget 1.20.3 - a non-interactive network retriever Mandatory arguments to long options are mandatory for short options too. Usage: wget [--help] Options & Flags: -h, --help Display this information","title":"introduction"},{"location":"user-guide/customizing-programs/#details","text":"details is a piece of text that goes after the list of arguments. It can be used, for example, to add some details that weren't relevant before, like website, documentation, or contact information. It is specified via the details member function. constexpr auto wget = Program ( \"wget\" , \"a non-interactive network retriever\" ) . version ( \"1.20.3\" ) . intro ( \"Mandatory arguments to long options are mandatory for short options too.\" ) . details ( \"Email bug reports, questions, discussions to <bug-wget@gnu.org>\" \" and/or open issues at https://savannah.gnu.org/bugs/?func=additem&group=wget.\" ); Note that C++ allows strings to be break into separate pieces for better code formatting, but that does not affect the output of the automatic help. Don't make it too long, though, as that will move the argument list up in the help text. Output of the snippet above: wget 1.20.3 - a non-interactive network retriever Mandatory arguments to long options are mandatory for short options too. Usage: wget [--help] Options & Flags: -h, --help Display this information Email bug reports, questions, discussions to <bug-wget@gnu.org> and/or open issues at https://savannah.gnu.org/bugs/?func=additem&group=wget.","title":"details"},{"location":"user-guide/customizing-programs/#msg_width","text":"The msg_width is what determines the maximum width of the messages that opzioni will output related to the program. For example, it is used when printing the automatic help and when using the built-in error handling actions. The default is 100 and it can be changed via the msg_width member function. constexpr auto wget = Program ( \"wget\" , \"a non-interactive network retriever\" ) . version ( \"1.20.3\" ) . intro ( \"Mandatory arguments to long options are mandatory for short options too.\" ) . details ( \"Email bug reports, questions, discussions to <bug-wget@gnu.org>\" \" and/or open issues at https://savannah.gnu.org/bugs/?func=additem&group=wget.\" ) . msg_width ( 64 ); Output of the snippet above: wget 1.20.3 - a non-interactive network retriever Mandatory arguments to long options are mandatory for short options too. Usage: wget [--help] Options & Flags: -h, --help Display this information Email bug reports, questions, discussions to <bug-wget@gnu.org> and/or open issues at https://savannah.gnu.org/bugs/?func=additem&group=wget. It is a best-effort, though, so don't make it too narrow. If the maximum width is not enough for long words (like the URL above), they will be printed in a dedicated line anyway (try this last snippet with a maximum width of 32).","title":"msg_width"},{"location":"user-guide/customizing-programs/#error_handler","text":"error_handler determines how the program behaves when a user error occurs. This doesn't affect the automatic help text. The default is to print the error message and the usage of the program. Changing it is done via the on_error member function. For example, to only print the error message: constexpr auto wget = Program ( \"wget\" , \"a non-interactive network retriever\" ) . version ( \"1.20.3\" ) . intro ( \"Mandatory arguments to long options are mandatory for short options too.\" ) . details ( \"Email bug reports, questions, discussions to <bug-wget@gnu.org>\" \" and/or open issues at https://savannah.gnu.org/bugs/?func=additem&group=wget.\" ) . msg_width ( 64 ) . on_error ( print_error ); This also deserves a longer documentation, but until that's available, here is a brief explanation: The argument to on_error must be of the ErrorHandler type, which is actually a using declaration for the following function pointer: using ErrorHandler = int ( * )( ProgramView const , UserError const & ); ProgramView was introduced earlier . UserError is the base class of the exceptions that are thrown when a user error occurs (user as in user of the command-line program). All opzioni exceptions inherit from std::exception , so the error message can be obtained via their what member function. Currently, the built-in error handlers are: print_error : print the error message only. print_error_and_usage : print the error message and the program usage (the default). rethrow : rethrow the exception. Just a detail about rethrow : note that, given the signature of ErrorHandler , the information of the actual class of the exception that was thrown is lost. In order to preserve their type information (and also be able to granularly catch exceptions, if that's desired), use the parse free function instead of Program 's call operator when parsing the command-line. Just add a try and as many catch es as desired to the following snippet: auto const map = parse ( wget , { argv , argc }); argc and argv are \"flipped\" and within {} because that's constructing a std::span . Calling parse instead of Program::operator() avoids the built-in try... catch (which invokes error_handler ). This means that \"unsetting\" or clearing error_handler isn't needed. In fact, on_error(nullptr) or on_error(NULL) doesn't compile. error_handler is a required attribute of Program . snippet output generated by adding the automatic help to the example. \u21a9","title":"error_handler"},{"location":"user-guide/running-with-docker/","text":"Running with Docker \u00b6 Since opzioni is not available in any package repository yet, this guide will cover trying it out with Docker, just like I do during development. First, make sure you have Docker and Docker Compose installed. Instructions for installing Docker can be found here (just select your OS) and for Compose here . If you're a VS Code user, you may want to install the Remote Development extension pack (ID ms-vscode-remote.vscode-remote-extensionpack ) to open the container in VS Code. Clone the repo. git clone https://github.com/ggabriel96/opzioni.git Run the container. If on VS Code, hit Ctrl + Shift + P and select the option Remote-Containers: Reopen in Container . If not on VS Code, you still might be able to open the project inside the container (e.g. with CLion), it just happens that I don't have a license and hence haven't tried it. If running the container through an IDE is not desired, you may open a terminal, navigate to the project, and run: docker build -f .devcontainer/Dockerfile -t opzioni . docker run --rm -it -v $( pwd ) :/home/conan/opzioni:Z -w /home/conan/opzioni/ opzioni The :Z option is unnecessary if not using SELinux. Having built and run the container from the terminal, you may edit any file from outside the container as usual. Once inside the container, run make . This will fetch the dependencies with Conan and build the whole project with Meson, including the examples and unit tests. run make build for additional builds run make test to run the unit tests run make format to format the code with ClangFormat run make clean to clean everything (after this, another full make is needed) You're done! The compiled examples will be in build/examples/ . For example, to run the main example: ./build/examples/main --help","title":"Running with Docker"},{"location":"user-guide/running-with-docker/#running-with-docker","text":"Since opzioni is not available in any package repository yet, this guide will cover trying it out with Docker, just like I do during development. First, make sure you have Docker and Docker Compose installed. Instructions for installing Docker can be found here (just select your OS) and for Compose here . If you're a VS Code user, you may want to install the Remote Development extension pack (ID ms-vscode-remote.vscode-remote-extensionpack ) to open the container in VS Code. Clone the repo. git clone https://github.com/ggabriel96/opzioni.git Run the container. If on VS Code, hit Ctrl + Shift + P and select the option Remote-Containers: Reopen in Container . If not on VS Code, you still might be able to open the project inside the container (e.g. with CLion), it just happens that I don't have a license and hence haven't tried it. If running the container through an IDE is not desired, you may open a terminal, navigate to the project, and run: docker build -f .devcontainer/Dockerfile -t opzioni . docker run --rm -it -v $( pwd ) :/home/conan/opzioni:Z -w /home/conan/opzioni/ opzioni The :Z option is unnecessary if not using SELinux. Having built and run the container from the terminal, you may edit any file from outside the container as usual. Once inside the container, run make . This will fetch the dependencies with Conan and build the whole project with Meson, including the examples and unit tests. run make build for additional builds run make test to run the unit tests run make format to format the code with ClangFormat run make clean to clean everything (after this, another full make is needed) You're done! The compiled examples will be in build/examples/ . For example, to run the main example: ./build/examples/main --help","title":"Running with Docker"},{"location":"user-guide/the-basics/","text":"The basics \u00b6 opzioni is made up of simple concepts: programs and arguments. A program is either the root or is a command of another program. Meanwhile, arguments describe the inputs that a program expects from the user. In code, programs are represented by Program and arguments by Arg . Including opzioni \u00b6 Including opzioni is as simple as include <opzioni.hpp> (or in quotes if building as an example ). For instance: #include <string_view> #include <fmt/format.h> #include \"opzioni.hpp\" int main ( int argc , char const * argv []) { using namespace opzioni ; } The using directive for the opzioni namespace is just to make things easier for now. You can always import the desired names individually later. Also, I'm using the awesome fmt library. You should check it out! Declaring a program \u00b6 In order to create a Program , we call one of its two constructors: one just takes a name; the other takes a name and a title: constexpr auto curl = Program ( \"curl\" , \"transfer a URL\" ); Note that it is marked constexpr , so it means that curl is a constant expression , that is, its value is known at compile-time. Adding arguments \u00b6 An argument can be one of three types: positional, option, or flag. These types are created via the functions Pos() , Opt() , and Flg() , respectively. Pos() only takes a name, while Opt() and Flg() take a name and an abbreviation. These functions are just helpers, since they all construct an Arg , but they set the appropriate values for the type of argument being created. These defaults are: positionals and options are initially of type std::string_view flags are initially of type bool positionals are required options and flags are optional options have \"\" as default value flags have false as default value Although possible, if the constructor of Arg were to be called, the argument type and all these defaults would have to be manually specified, requiring more typing. Arguments are added to a program via its operator + , but first are gathered into an array via their operator * . These choices relate to operator precedence, since we first need to build the array, then add the array of arguments to the program. Building an array is needed so we can verify that all argument names are unique, for example. Let's add some arguments to our curl program: constexpr auto curl = Program ( \"curl\" , \"transfer a URL\" ) + Pos ( \"url\" ). help ( \"The URL to transfer\" ) * Opt ( \"request\" , \"X\" ). help ( \"The HTTP method to use\" ) * Flg ( \"verbose\" , \"v\" ). help ( \"Make the operation more talkative\" ) * Help (); Since we get an Arg after calling one of the three argument factories, we can further customize it with its member functions. The first one we are presented here is .help() , which serves the purpose of setting descriptions to arguments. These descriptions are what appears in the automatic help text that opzioni generates. To tell opzioni that automatic help text is desired, we simply call Help() . Similar to the previous functions, it's just a helper, but this time to create a very common flag, which is to show the program help. Parsing the CLI \u00b6 Now that our very simple curl has some arguments, we can try parsing the CLI and see what we get. We just need to call curl with argc and argv : auto const map = curl ( argc , argv ); The result is a map of arguments of what was parsed from the CLI. Note that map is not constexpr , since its value depends on runtime information. opzioni also provide automatic error handling when calling the call operator of Program . This means that, if the user gives curl some invalid arguments, the default behavior is to terminate the program and show an error message alongside the usage of the program. This is explained later, but this behavior can be changed either while keeping the automatic error handling or not. Getting the results \u00b6 There are a few ways of getting the results out of the map: std :: string_view const url = map [ \"url\" ]; // 1 auto const url = map . as < std :: string_view > ( \"url\" ); // 2 auto const url = map [ \"url\" ]. as < std :: string_view > (); // 3 Choose whichever you like most. However, it is always the long name of the argument that is used to get the result from the map. So, for example, to get the value of the request option, it's always via the name request , never X . Now let's print them out! std :: string_view const url = map [ \"url\" ]; std :: string_view const request = map [ \"request\" ]; bool const verbose = map [ \"verbose\" ]; fmt :: print ( \"url: {} \\n \" , url ); fmt :: print ( \"request: {} \\n \" , request ); fmt :: print ( \"verbose: {} \\n \" , verbose ); Full C++ code \u00b6 #include <string_view> #include <fmt/format.h> #include \"opzioni.hpp\" int main ( int argc , char const * argv []) { using namespace opzioni ; constexpr auto curl = Program ( \"curl\" , \"transfer a URL\" ) + Pos ( \"url\" ). help ( \"The URL to transfer\" ) * Opt ( \"request\" , \"X\" ). help ( \"The HTTP method to use\" ) * Flg ( \"verbose\" , \"v\" ). help ( \"Make the operation more talkative\" ) * Help (); auto const map = curl ( argc , argv ); std :: string_view const url = map [ \"url\" ]; std :: string_view const request = map [ \"request\" ]; bool const verbose = map [ \"verbose\" ]; fmt :: print ( \"url: {} \\n \" , url ); fmt :: print ( \"request: {} \\n \" , request ); fmt :: print ( \"verbose: {} \\n \" , verbose ); } Building as an example \u00b6 Put the code above in a file in the examples/ directory, say, curl.cpp . Add an executable entry for it in examples/meson.build , just like the other examples. curl = executable ( 'curl' , 'curl.cpp' , dependencies : [ fmt_dep , opzioni_dep ] ) Run make build Test your new CLI! See the automatic help: ./build/examples/curl --help Test that URL is really required by giving no arguments to the executable: ./build/examples/curl Give it a valid set of arguments and see the output: ./build/examples/curl -X GET google.com Supported formats of arguments \u00b6 There are many ways in which a user might provide arguments to a program. The following list contains the rules that opzioni follows when parsing them. Arguments that don't start with - or are just a single - are considered positionals. Example: rm file.txt , where file.txt is a positional argument of rm . Commands are a special case of positional arguments in which they exactly match the name of some program added as command. Example: git clone <clone args...> , where clone is a command of git . An argument starting with a single - followed by one or more letters can be one short flag or many short flags together if all characters match the abbreviation of existing flags; or a short option immediately followed by its value if the first character matches the abbreviation of an existing option. In the case of an option, the value may be optionally preceded by = or it can be the next argument in the command-line. Example: pip -h , where h is a flag of pip . tar -vxz , where vxz are three flags of tar . g++ -O2 or g++ -O=2 , where O is an option of g++ and 2 is its value. Note that both -O2 and -O=2 are a single argument. curl -X GET , where X is an option of curl and GET is its value. This is a special case in which the argument ( -X ) is an existing option and the argument that immediately follows it would be parsed as a positional argument. Passing arguments like set -euxo pipefail is intentionally not supported . The format -abc always means many flags together or an option a followed by its value bc . An argument starting with two - followed by any number of characters is either a flag or an option. it is considered a flag If the name exactly matches an existing flag, otherwise it is considered an option. In the case of an option, the value may be optionally preceded by = or it can be the next argument in the command-line. Example: pip --help , where help is a flag of pip . wget --timeout=10 , where timeout is an option of wget and 10 is its value. Note that --timeout=10 is a single argument and --timeout10 would not work the same way (it would be parsed as a flag). wget --user-agent Firefox , where user-agent is an option of wget and Firefox is its value. Similarly to short flags and options, this is a special case in which the argument ( --user-agent ) is an existing option and the argument that immediately follows it would be parsed as a positional argument. An argument that is exactly -- indicates that everything that follows should always be parsed as positional arguments.","title":"The basics"},{"location":"user-guide/the-basics/#the-basics","text":"opzioni is made up of simple concepts: programs and arguments. A program is either the root or is a command of another program. Meanwhile, arguments describe the inputs that a program expects from the user. In code, programs are represented by Program and arguments by Arg .","title":"The basics"},{"location":"user-guide/the-basics/#including-opzioni","text":"Including opzioni is as simple as include <opzioni.hpp> (or in quotes if building as an example ). For instance: #include <string_view> #include <fmt/format.h> #include \"opzioni.hpp\" int main ( int argc , char const * argv []) { using namespace opzioni ; } The using directive for the opzioni namespace is just to make things easier for now. You can always import the desired names individually later. Also, I'm using the awesome fmt library. You should check it out!","title":"Including opzioni"},{"location":"user-guide/the-basics/#declaring-a-program","text":"In order to create a Program , we call one of its two constructors: one just takes a name; the other takes a name and a title: constexpr auto curl = Program ( \"curl\" , \"transfer a URL\" ); Note that it is marked constexpr , so it means that curl is a constant expression , that is, its value is known at compile-time.","title":"Declaring a program"},{"location":"user-guide/the-basics/#adding-arguments","text":"An argument can be one of three types: positional, option, or flag. These types are created via the functions Pos() , Opt() , and Flg() , respectively. Pos() only takes a name, while Opt() and Flg() take a name and an abbreviation. These functions are just helpers, since they all construct an Arg , but they set the appropriate values for the type of argument being created. These defaults are: positionals and options are initially of type std::string_view flags are initially of type bool positionals are required options and flags are optional options have \"\" as default value flags have false as default value Although possible, if the constructor of Arg were to be called, the argument type and all these defaults would have to be manually specified, requiring more typing. Arguments are added to a program via its operator + , but first are gathered into an array via their operator * . These choices relate to operator precedence, since we first need to build the array, then add the array of arguments to the program. Building an array is needed so we can verify that all argument names are unique, for example. Let's add some arguments to our curl program: constexpr auto curl = Program ( \"curl\" , \"transfer a URL\" ) + Pos ( \"url\" ). help ( \"The URL to transfer\" ) * Opt ( \"request\" , \"X\" ). help ( \"The HTTP method to use\" ) * Flg ( \"verbose\" , \"v\" ). help ( \"Make the operation more talkative\" ) * Help (); Since we get an Arg after calling one of the three argument factories, we can further customize it with its member functions. The first one we are presented here is .help() , which serves the purpose of setting descriptions to arguments. These descriptions are what appears in the automatic help text that opzioni generates. To tell opzioni that automatic help text is desired, we simply call Help() . Similar to the previous functions, it's just a helper, but this time to create a very common flag, which is to show the program help.","title":"Adding arguments"},{"location":"user-guide/the-basics/#parsing-the-cli","text":"Now that our very simple curl has some arguments, we can try parsing the CLI and see what we get. We just need to call curl with argc and argv : auto const map = curl ( argc , argv ); The result is a map of arguments of what was parsed from the CLI. Note that map is not constexpr , since its value depends on runtime information. opzioni also provide automatic error handling when calling the call operator of Program . This means that, if the user gives curl some invalid arguments, the default behavior is to terminate the program and show an error message alongside the usage of the program. This is explained later, but this behavior can be changed either while keeping the automatic error handling or not.","title":"Parsing the CLI"},{"location":"user-guide/the-basics/#getting-the-results","text":"There are a few ways of getting the results out of the map: std :: string_view const url = map [ \"url\" ]; // 1 auto const url = map . as < std :: string_view > ( \"url\" ); // 2 auto const url = map [ \"url\" ]. as < std :: string_view > (); // 3 Choose whichever you like most. However, it is always the long name of the argument that is used to get the result from the map. So, for example, to get the value of the request option, it's always via the name request , never X . Now let's print them out! std :: string_view const url = map [ \"url\" ]; std :: string_view const request = map [ \"request\" ]; bool const verbose = map [ \"verbose\" ]; fmt :: print ( \"url: {} \\n \" , url ); fmt :: print ( \"request: {} \\n \" , request ); fmt :: print ( \"verbose: {} \\n \" , verbose );","title":"Getting the results"},{"location":"user-guide/the-basics/#full-c-code","text":"#include <string_view> #include <fmt/format.h> #include \"opzioni.hpp\" int main ( int argc , char const * argv []) { using namespace opzioni ; constexpr auto curl = Program ( \"curl\" , \"transfer a URL\" ) + Pos ( \"url\" ). help ( \"The URL to transfer\" ) * Opt ( \"request\" , \"X\" ). help ( \"The HTTP method to use\" ) * Flg ( \"verbose\" , \"v\" ). help ( \"Make the operation more talkative\" ) * Help (); auto const map = curl ( argc , argv ); std :: string_view const url = map [ \"url\" ]; std :: string_view const request = map [ \"request\" ]; bool const verbose = map [ \"verbose\" ]; fmt :: print ( \"url: {} \\n \" , url ); fmt :: print ( \"request: {} \\n \" , request ); fmt :: print ( \"verbose: {} \\n \" , verbose ); }","title":"Full C++ code"},{"location":"user-guide/the-basics/#building-as-an-example","text":"Put the code above in a file in the examples/ directory, say, curl.cpp . Add an executable entry for it in examples/meson.build , just like the other examples. curl = executable ( 'curl' , 'curl.cpp' , dependencies : [ fmt_dep , opzioni_dep ] ) Run make build Test your new CLI! See the automatic help: ./build/examples/curl --help Test that URL is really required by giving no arguments to the executable: ./build/examples/curl Give it a valid set of arguments and see the output: ./build/examples/curl -X GET google.com","title":"Building as an example"},{"location":"user-guide/the-basics/#supported-formats-of-arguments","text":"There are many ways in which a user might provide arguments to a program. The following list contains the rules that opzioni follows when parsing them. Arguments that don't start with - or are just a single - are considered positionals. Example: rm file.txt , where file.txt is a positional argument of rm . Commands are a special case of positional arguments in which they exactly match the name of some program added as command. Example: git clone <clone args...> , where clone is a command of git . An argument starting with a single - followed by one or more letters can be one short flag or many short flags together if all characters match the abbreviation of existing flags; or a short option immediately followed by its value if the first character matches the abbreviation of an existing option. In the case of an option, the value may be optionally preceded by = or it can be the next argument in the command-line. Example: pip -h , where h is a flag of pip . tar -vxz , where vxz are three flags of tar . g++ -O2 or g++ -O=2 , where O is an option of g++ and 2 is its value. Note that both -O2 and -O=2 are a single argument. curl -X GET , where X is an option of curl and GET is its value. This is a special case in which the argument ( -X ) is an existing option and the argument that immediately follows it would be parsed as a positional argument. Passing arguments like set -euxo pipefail is intentionally not supported . The format -abc always means many flags together or an option a followed by its value bc . An argument starting with two - followed by any number of characters is either a flag or an option. it is considered a flag If the name exactly matches an existing flag, otherwise it is considered an option. In the case of an option, the value may be optionally preceded by = or it can be the next argument in the command-line. Example: pip --help , where help is a flag of pip . wget --timeout=10 , where timeout is an option of wget and 10 is its value. Note that --timeout=10 is a single argument and --timeout10 would not work the same way (it would be parsed as a flag). wget --user-agent Firefox , where user-agent is an option of wget and Firefox is its value. Similarly to short flags and options, this is a special case in which the argument ( --user-agent ) is an existing option and the argument that immediately follows it would be parsed as a positional argument. An argument that is exactly -- indicates that everything that follows should always be parsed as positional arguments.","title":"Supported formats of arguments"}]}