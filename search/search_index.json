{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 opzioni is a command line arguments parser library for C++. Goals \u00b6 The goals of this library, in order of importance, are: Be as simple and enjoyable as possible. This mainly targets the user of the library, but also includes the user of the command line tool built with it. constexpr -all-the-things. Most of the time, all the information needed to build a command line interface is available at compile-time, so we should take advantage of that. If it compiles, it works. That's utopic, but that's what is being strived for. It's also very closely related to the previous goal. We should be able to detect most errors at compile-time and provide decent diagnostics. Try not to repeat yourself. When specifying a CLI, if some information was already given to the library, that same information should not be needed again. For example, if the type of an argument was already specified, the user should not be asked to tell the type again. Unfortunately that is very hard, so some places still require duplicate information. Be bleeding-edge. This library requires C++20. That limits a lot its potential users, but also allows for the use of the new and powerful features of C++. It also helps to accomplish the previous goals. Disclaimer \u00b6 This is a personal project with no promise of maintainability for the time being. I started it to learn more about C++ and its new features. Although it is not in early development, since I'm working on it for months and iterated over it many times, it is not stable or production-ready . There are many unit tests missing . I frequently changed the interface of the library and I'm not afraid of changing it radically again if I think it would improve the UX. Another example is the names of the namespaces and what is in them. There is a lot of polish and optimization work to do. There is a whole documentation to write. Sneak peek \u00b6 The code below is a fully working example, taken from examples/hello.cpp , only reformatted and with quotes changed to angle brackets in the #include . Feel free to take a look at the other, more complex, examples in the same directory. #include <iostream> #include <string_view> #include <opzioni.hpp> int main ( int argc , char const * argv []) { using namespace opzioni ; constexpr auto hello = Program ( \"hello\" ). version ( \"0.1\" ). intro ( \"Greeting people since the dawn of computing\" ) + Help () * Version () * Pos ( \"name\" ). help ( \"Your name please, so I can greet you\" ); auto const args = hello ( argc , argv ); std :: string_view const name = args [ \"name\" ]; std :: cout << \"Hello, \" << name << \"! \\n \" ; } That gives us: Automatic help with --help or -h $ ./build/examples/hello -h hello 0.1 Greeting people since the dawn of computing Usage: hello <name> [--help] [--version] Positionals: name Your name please, so I can greet you Options & Flags: -h, --help Display this information -V, --version Display the software version Automatic version with --version or -V $ ./build/examples/hello -V hello 0 .1 Automatic error handling $ ./build/examples/hello Gabriel Galli Unexpected positional argument `Galli`. This program expects 1 positional arguments Usage: hello <name> [--help] [--version] And finally: $ ./build/examples/hello \"Gabriel Galli\" Hello, Gabriel Galli! Getting started \u00b6 opzioni is not published anywhere yet. The goal is to eventually make it available on: Conan vcpkg Meson's Wrap DB conda-forge Spack Meanwhile, there are a few options to build and try it out. See the TLDR below. TLDR \u00b6 There are few options to get up to speed on building opzioni: If you're familiar with Docker, there is a Dockerfile and a docker-compose.yml in .devcontainer/ . Also, the project is already configured to work with VS Code Remote Containers . If you're familiar with NixOS , there is a shell.nix ready to use. Once in your chosen environment, simply run make . That should download the build dependencies with Conan and build the whole project with Meson and ninja. The Makefile is just a simple helper to avoid having to remember all the commands. Dependencies \u00b6 All dependencies below might still work if on earlier minor versions, but I'm not sure. I still gotta pin them (except for fmt and Catch2 , which are somewhat pinned in the build definitions). I always try to go for the latest versions. GCC >= 10.2. Concepts and Ranges support is required. meson >= 0.50 (gotta check that) ninja >= 1.10 fmt >= 7.0.3 Catch2 >= 2.13.0 ClangFormat 10 if willing to apply the formatting as checked in CI License \u00b6 opzioni's license is the Boost Software License (BSL) 1.0 . This means you are free to use this library as you wish and see fit. It is only needed to provide a copy of the license if the source is also being distributed. In other words, there is no need to bundle opzioni's license with your binary .","title":"Home"},{"location":"#home","text":"opzioni is a command line arguments parser library for C++.","title":"Home"},{"location":"#goals","text":"The goals of this library, in order of importance, are: Be as simple and enjoyable as possible. This mainly targets the user of the library, but also includes the user of the command line tool built with it. constexpr -all-the-things. Most of the time, all the information needed to build a command line interface is available at compile-time, so we should take advantage of that. If it compiles, it works. That's utopic, but that's what is being strived for. It's also very closely related to the previous goal. We should be able to detect most errors at compile-time and provide decent diagnostics. Try not to repeat yourself. When specifying a CLI, if some information was already given to the library, that same information should not be needed again. For example, if the type of an argument was already specified, the user should not be asked to tell the type again. Unfortunately that is very hard, so some places still require duplicate information. Be bleeding-edge. This library requires C++20. That limits a lot its potential users, but also allows for the use of the new and powerful features of C++. It also helps to accomplish the previous goals.","title":"Goals"},{"location":"#disclaimer","text":"This is a personal project with no promise of maintainability for the time being. I started it to learn more about C++ and its new features. Although it is not in early development, since I'm working on it for months and iterated over it many times, it is not stable or production-ready . There are many unit tests missing . I frequently changed the interface of the library and I'm not afraid of changing it radically again if I think it would improve the UX. Another example is the names of the namespaces and what is in them. There is a lot of polish and optimization work to do. There is a whole documentation to write.","title":"Disclaimer"},{"location":"#sneak-peek","text":"The code below is a fully working example, taken from examples/hello.cpp , only reformatted and with quotes changed to angle brackets in the #include . Feel free to take a look at the other, more complex, examples in the same directory. #include <iostream> #include <string_view> #include <opzioni.hpp> int main ( int argc , char const * argv []) { using namespace opzioni ; constexpr auto hello = Program ( \"hello\" ). version ( \"0.1\" ). intro ( \"Greeting people since the dawn of computing\" ) + Help () * Version () * Pos ( \"name\" ). help ( \"Your name please, so I can greet you\" ); auto const args = hello ( argc , argv ); std :: string_view const name = args [ \"name\" ]; std :: cout << \"Hello, \" << name << \"! \\n \" ; } That gives us: Automatic help with --help or -h $ ./build/examples/hello -h hello 0.1 Greeting people since the dawn of computing Usage: hello <name> [--help] [--version] Positionals: name Your name please, so I can greet you Options & Flags: -h, --help Display this information -V, --version Display the software version Automatic version with --version or -V $ ./build/examples/hello -V hello 0 .1 Automatic error handling $ ./build/examples/hello Gabriel Galli Unexpected positional argument `Galli`. This program expects 1 positional arguments Usage: hello <name> [--help] [--version] And finally: $ ./build/examples/hello \"Gabriel Galli\" Hello, Gabriel Galli!","title":"Sneak peek"},{"location":"#getting-started","text":"opzioni is not published anywhere yet. The goal is to eventually make it available on: Conan vcpkg Meson's Wrap DB conda-forge Spack Meanwhile, there are a few options to build and try it out. See the TLDR below.","title":"Getting started"},{"location":"#tldr","text":"There are few options to get up to speed on building opzioni: If you're familiar with Docker, there is a Dockerfile and a docker-compose.yml in .devcontainer/ . Also, the project is already configured to work with VS Code Remote Containers . If you're familiar with NixOS , there is a shell.nix ready to use. Once in your chosen environment, simply run make . That should download the build dependencies with Conan and build the whole project with Meson and ninja. The Makefile is just a simple helper to avoid having to remember all the commands.","title":"TLDR"},{"location":"#dependencies","text":"All dependencies below might still work if on earlier minor versions, but I'm not sure. I still gotta pin them (except for fmt and Catch2 , which are somewhat pinned in the build definitions). I always try to go for the latest versions. GCC >= 10.2. Concepts and Ranges support is required. meson >= 0.50 (gotta check that) ninja >= 1.10 fmt >= 7.0.3 Catch2 >= 2.13.0 ClangFormat 10 if willing to apply the formatting as checked in CI","title":"Dependencies"},{"location":"#license","text":"opzioni's license is the Boost Software License (BSL) 1.0 . This means you are free to use this library as you wish and see fit. It is only needed to provide a copy of the license if the source is also being distributed. In other words, there is no need to bundle opzioni's license with your binary .","title":"License"}]}