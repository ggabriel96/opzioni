{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"opzioni \u00b6 opzioni is a command line arguments parser library for C++. Goals \u00b6 The goals of this library, in order of importance, are: Be as simple and enjoyable as possible. This mainly targets the user of the library, but also includes the user of the command line tool built with it. constexpr -all-the-things. Most of the time, all the information needed to build a command line interface is available at compile-time, so we should take advantage of that. If it compiles, it works. That's utopic, but that's what is being strived for. It's also very closely related to the previous goal. We should be able to detect most errors at compile-time and provide decent diagnostics. Try not to repeat yourself. When specifying a CLI, if some information was already given to the library, that same information should not be needed again. For example, if the type of an argument was already specified, the user should not be asked to tell the type again. Unfortunately that is very hard, so some places still require duplicate information. Be bleeding-edge. This library requires C++20. That limits a lot its potential users, but also allows for the use of the new and powerful features of C++. It also helps to accomplish the previous goals. Disclaimer \u00b6 This is a personal project with no promise of maintainability for the time being. I started it to learn more about C++ and its new features. Although it is not in early development, since I'm working on it for months and iterated over it many times, it is not stable or production-ready . There are many unit tests missing . I frequently changed the interface of the library and I'm not afraid of changing it radically again if I think it would improve the UX. Another example is the names of the namespaces and what is in them. There is a lot of polish and optimization work to do. There is a whole documentation to write. Sneak peek \u00b6 The code below is a fully working example, taken from examples/hello.cpp , only reformatted and with quotes changed to angle brackets in the #include . Feel free to take a look at the other, more complex, examples in the same directory. #include <iostream> #include <string_view> #include <opzioni.hpp> int main ( int argc , char const * argv []) { using namespace opzioni ; constexpr auto hello = Program ( \"hello\" ). version ( \"0.1\" ). intro ( \"Greeting people since the dawn of computing\" ) + Pos ( \"name\" ). help ( \"Your name please, so I can greet you\" ) * Help () * Version (); auto const args = hello ( argc , argv ); std :: string_view const name = args [ \"name\" ]; std :: cout << \"Hello, \" << name << \"! \\n \" ; } That gives us: Automatic help with --help or -h $ ./build/examples/hello -h hello 0.1 Greeting people since the dawn of computing Usage: hello <name> [--help] [--version] Positionals: name Your name please, so I can greet you Options & Flags: -h, --help Display this information -V, --version Display the software version Automatic version with --version or -V $ ./build/examples/hello -V hello 0.1 Automatic error handling $ ./build/examples/hello Gabriel Galli Unexpected positional argument `Galli`. This program expects 1 positional arguments Usage: hello <name> [--help] [--version] And finally: $ ./build/examples/hello \"Gabriel Galli\" Hello, Gabriel Galli! Getting started \u00b6 opzioni is not published anywhere yet. The goal is to eventually make it available on: Conan vcpkg Meson's Wrap DB conda-forge Spack Meanwhile, there are a few options to build and try it out. See the TLDR below. TLDR \u00b6 There are few options to get up to speed on building opzioni: If you're familiar with Docker, there is a Dockerfile and a docker-compose.yml in .devcontainer/ . Also, the project is already configured to work with VS Code Remote Containers . If you're familiar with NixOS , there is a shell.nix ready to use. Once in your chosen environment, simply run make . That should download the build dependencies with Conan and build the whole project with Meson and ninja. The Makefile is just a simple helper to avoid having to remember all the commands. Dependencies \u00b6 All dependencies below might still work if on earlier minor versions, but I'm not sure. I still gotta pin them (except for fmt and Catch2 , which are somewhat pinned in the build definitions). I always try to go for the latest versions. GCC >= 10.2. Concepts and Ranges support is required. meson >= 0.50 (gotta check that) ninja >= 1.10 fmt >= 7.0.3 Catch2 >= 2.13.0 ClangFormat 10 if willing to apply the formatting as checked in CI License \u00b6 opzioni's license is the Boost Software License (BSL) 1.0 . This means you are free to use this library as you wish and see fit. It is only needed to provide a copy of the license if the source is also being distributed. In other words, there is no need to bundle opzioni's license with your binary .","title":"Home"},{"location":"#opzioni","text":"opzioni is a command line arguments parser library for C++.","title":"opzioni"},{"location":"#goals","text":"The goals of this library, in order of importance, are: Be as simple and enjoyable as possible. This mainly targets the user of the library, but also includes the user of the command line tool built with it. constexpr -all-the-things. Most of the time, all the information needed to build a command line interface is available at compile-time, so we should take advantage of that. If it compiles, it works. That's utopic, but that's what is being strived for. It's also very closely related to the previous goal. We should be able to detect most errors at compile-time and provide decent diagnostics. Try not to repeat yourself. When specifying a CLI, if some information was already given to the library, that same information should not be needed again. For example, if the type of an argument was already specified, the user should not be asked to tell the type again. Unfortunately that is very hard, so some places still require duplicate information. Be bleeding-edge. This library requires C++20. That limits a lot its potential users, but also allows for the use of the new and powerful features of C++. It also helps to accomplish the previous goals.","title":"Goals"},{"location":"#disclaimer","text":"This is a personal project with no promise of maintainability for the time being. I started it to learn more about C++ and its new features. Although it is not in early development, since I'm working on it for months and iterated over it many times, it is not stable or production-ready . There are many unit tests missing . I frequently changed the interface of the library and I'm not afraid of changing it radically again if I think it would improve the UX. Another example is the names of the namespaces and what is in them. There is a lot of polish and optimization work to do. There is a whole documentation to write.","title":"Disclaimer"},{"location":"#sneak-peek","text":"The code below is a fully working example, taken from examples/hello.cpp , only reformatted and with quotes changed to angle brackets in the #include . Feel free to take a look at the other, more complex, examples in the same directory. #include <iostream> #include <string_view> #include <opzioni.hpp> int main ( int argc , char const * argv []) { using namespace opzioni ; constexpr auto hello = Program ( \"hello\" ). version ( \"0.1\" ). intro ( \"Greeting people since the dawn of computing\" ) + Pos ( \"name\" ). help ( \"Your name please, so I can greet you\" ) * Help () * Version (); auto const args = hello ( argc , argv ); std :: string_view const name = args [ \"name\" ]; std :: cout << \"Hello, \" << name << \"! \\n \" ; } That gives us: Automatic help with --help or -h $ ./build/examples/hello -h hello 0.1 Greeting people since the dawn of computing Usage: hello <name> [--help] [--version] Positionals: name Your name please, so I can greet you Options & Flags: -h, --help Display this information -V, --version Display the software version Automatic version with --version or -V $ ./build/examples/hello -V hello 0.1 Automatic error handling $ ./build/examples/hello Gabriel Galli Unexpected positional argument `Galli`. This program expects 1 positional arguments Usage: hello <name> [--help] [--version] And finally: $ ./build/examples/hello \"Gabriel Galli\" Hello, Gabriel Galli!","title":"Sneak peek"},{"location":"#getting-started","text":"opzioni is not published anywhere yet. The goal is to eventually make it available on: Conan vcpkg Meson's Wrap DB conda-forge Spack Meanwhile, there are a few options to build and try it out. See the TLDR below.","title":"Getting started"},{"location":"#tldr","text":"There are few options to get up to speed on building opzioni: If you're familiar with Docker, there is a Dockerfile and a docker-compose.yml in .devcontainer/ . Also, the project is already configured to work with VS Code Remote Containers . If you're familiar with NixOS , there is a shell.nix ready to use. Once in your chosen environment, simply run make . That should download the build dependencies with Conan and build the whole project with Meson and ninja. The Makefile is just a simple helper to avoid having to remember all the commands.","title":"TLDR"},{"location":"#dependencies","text":"All dependencies below might still work if on earlier minor versions, but I'm not sure. I still gotta pin them (except for fmt and Catch2 , which are somewhat pinned in the build definitions). I always try to go for the latest versions. GCC >= 10.2. Concepts and Ranges support is required. meson >= 0.50 (gotta check that) ninja >= 1.10 fmt >= 7.0.3 Catch2 >= 2.13.0 ClangFormat 10 if willing to apply the formatting as checked in CI","title":"Dependencies"},{"location":"#license","text":"opzioni's license is the Boost Software License (BSL) 1.0 . This means you are free to use this library as you wish and see fit. It is only needed to provide a copy of the license if the source is also being distributed. In other words, there is no need to bundle opzioni's license with your binary .","title":"License"},{"location":"user-guide/customization/","text":"Customization \u00b6 Program \u00b6 The following sections explain the various attributes of Program and how to set them via the provided member functions. In code, however, they are not member variables of Program (that's why I called them attributes instead). They are actually member variables of the ProgramMetadata class, held in the metadata member variable of Program . This detail deserves a longer explanation somewhere else, so to keep things short here, it suffices to say that it serves the purpose of having a common data structure between Program and ProgramView . ProgramView is like a std::string_view , but for Program . All program data is accessible through it, including its arguments and commands. name \u00b6 The first and most basic information of Program is name . It is the only attribute that the user is required to provide. Thus, it is specified in the constructor: constexpr auto wget = Program ( \"wget\" ); It is used, for example, when printing the automatic help text, and as identifier when adding a program as command of another program. Output of the snippet above 1 : wget Usage: wget [--help] Options & Flags: -h, --help Display this information title \u00b6 The title is like the headline of the program. It is optional, but is also given in the constructor, as the second argument: constexpr auto wget = Program ( \"wget\" , \"a non-interactive network retriever\" ); There is currently no special use for it, so it is only informational. Output of the snippet above: wget - a non-interactive network retriever Usage: wget [--help] Options & Flags: -h, --help Display this information version \u00b6 version is... well, the program version. It is specified via the version member function and can be any string. constexpr auto wget = Program ( \"wget\" , \"a non-interactive network retriever\" ) . version ( \"1.20.3\" ); In the automatic help, it is printed right next to the program name in the title line, so it is best to keep it within a maximum of ~16 characters. Output of the snippet above: wget 1.20.3 - a non-interactive network retriever Usage: wget [--help] Options & Flags: -h, --help Display this information introduction \u00b6 introduction is what goes between the program name and its list of arguments. So, for example, it can be used as an actual introduction to the program and what is does, or some message about its usage. It is specified via the intro member function. Try to keep it short (2 or 3 lines maximum). constexpr auto wget = Program ( \"wget\" , \"a non-interactive network retriever\" ) . version ( \"1.20.3\" ) . intro ( \"Mandatory arguments to long options are mandatory for short options too.\" ); Output of the snippet above: wget 1.20.3 - a non-interactive network retriever Mandatory arguments to long options are mandatory for short options too. Usage: wget [--help] Options & Flags: -h, --help Display this information Just keep in mind that the introduction is used as a description for commands in the automatic help text of their parent program. In that case, an actual introduction is recommended. So an introduction like the example above is OK if the program is the root program. details \u00b6 details is a piece of text that goes after the list of arguments. It can be used, for example, to add some details that weren't relevant before, like website, documentation, or contact information. It is specified via the details member function. constexpr auto wget = Program ( \"wget\" , \"a non-interactive network retriever\" ) . version ( \"1.20.3\" ) . intro ( \"Mandatory arguments to long options are mandatory for short options too.\" ) . details ( \"Email bug reports, questions, discussions to <bug-wget@gnu.org>\" \" and/or open issues at https://savannah.gnu.org/bugs/?func=additem&group=wget.\" ); Note that C++ allows strings to be break into separate pieces for better code formatting, but that does not affect the output of the automatic help. Don't make it too long, though, as that will move the argument list up in the help text. Output of the snippet above: wget 1.20.3 - a non-interactive network retriever Mandatory arguments to long options are mandatory for short options too. Usage: wget [--help] Options & Flags: -h, --help Display this information Email bug reports, questions, discussions to <bug-wget@gnu.org> and/or open issues at https://savannah.gnu.org/bugs/?func=additem&group=wget. msg_width \u00b6 The msg_width is what determines the maximum width of the messages that opzioni will output related to the program. For example, it is used when printing the automatic help and when using the built-in error handling actions. The default is 100 and it can be changed via the max_width member function. constexpr auto wget = Program ( \"wget\" , \"a non-interactive network retriever\" ) . version ( \"1.20.3\" ) . intro ( \"Mandatory arguments to long options are mandatory for short options too.\" ) . details ( \"Email bug reports, questions, discussions to <bug-wget@gnu.org>\" \" and/or open issues at https://savannah.gnu.org/bugs/?func=additem&group=wget.\" ) . max_width ( 64 ); Output of the snippet above: wget 1.20.3 - a non-interactive network retriever Mandatory arguments to long options are mandatory for short options too. Usage: wget [--help] Options & Flags: -h, --help Display this information Email bug reports, questions, discussions to <bug-wget@gnu.org> and/or open issues at https://savannah.gnu.org/bugs/?func=additem&group=wget. It is a best-effort, though, so don't make it too narrow. If the maximum width is not enough for long words (like the URL above), they will be printed in a dedicated line anyway (try this last snippet with a maximum width of 32). error_handler \u00b6 error_handler determines how the program behaves when a user error occurs. This doesn't affect the automatic help text. The default is to print the error message and the usage of the program. Change it via the on_error member function. For example, to only print the error message: constexpr auto wget = Program ( \"wget\" , \"a non-interactive network retriever\" ) . version ( \"1.20.3\" ) . intro ( \"Mandatory arguments to long options are mandatory for short options too.\" ) . details ( \"Email bug reports, questions, discussions to <bug-wget@gnu.org>\" \" and/or open issues at https://savannah.gnu.org/bugs/?func=additem&group=wget.\" ) . max_width ( 64 ) . on_error ( print_error ); This also deserves a longer documentation, but until that's available, here is a brief explanation: The argument to on_error must be of the ErrorHandler type, which is actually a using declaration for the following function pointer: using ErrorHandler = int ( * )( ProgramView const , UserError const & ); ProgramView was introduced earlier . UserError is the base class of the exceptions that are thrown when a user error occurs (user as in user of the command-line program). All opzioni exceptions inherit from std::exception , so the error message can be obtained via their what member function. Currently, the built-in error handlers are: print_error : print the error message only. print_error_and_usage : print the error message and the program usage (the default). rethrow : rethrow the exception. Just a detail about rethrow : note that, given the signature of ErrorHandler , the information of the actual class of the exception that was thrown is lost. In order to preserve their type information (and also be able to granularly catch exceptions, if that's desired), use the parse free function instead of Program 's call operator when parsing the command-line. Just add a try and as many catch es as desired to the following snippet: auto const map = parse ( wget , { argv , argc }); argc and argv are \"flipped\" and within {} because that's constructing a std::span . Calling parse instead of Program::operator() avoids the built-in try... catch (which invokes error_handler ). This means that \"unsetting\" or clearing error_handler isn't needed. In fact, on_error(nullptr) or on_error(NULL) doesn't compile. error_handler is a required attribute of Program . snippet output generated by adding the automatic help to the example. \u21a9","title":"Customization"},{"location":"user-guide/customization/#customization","text":"","title":"Customization"},{"location":"user-guide/customization/#program","text":"The following sections explain the various attributes of Program and how to set them via the provided member functions. In code, however, they are not member variables of Program (that's why I called them attributes instead). They are actually member variables of the ProgramMetadata class, held in the metadata member variable of Program . This detail deserves a longer explanation somewhere else, so to keep things short here, it suffices to say that it serves the purpose of having a common data structure between Program and ProgramView . ProgramView is like a std::string_view , but for Program . All program data is accessible through it, including its arguments and commands.","title":"Program"},{"location":"user-guide/customization/#name","text":"The first and most basic information of Program is name . It is the only attribute that the user is required to provide. Thus, it is specified in the constructor: constexpr auto wget = Program ( \"wget\" ); It is used, for example, when printing the automatic help text, and as identifier when adding a program as command of another program. Output of the snippet above 1 : wget Usage: wget [--help] Options & Flags: -h, --help Display this information","title":"name"},{"location":"user-guide/customization/#title","text":"The title is like the headline of the program. It is optional, but is also given in the constructor, as the second argument: constexpr auto wget = Program ( \"wget\" , \"a non-interactive network retriever\" ); There is currently no special use for it, so it is only informational. Output of the snippet above: wget - a non-interactive network retriever Usage: wget [--help] Options & Flags: -h, --help Display this information","title":"title"},{"location":"user-guide/customization/#version","text":"version is... well, the program version. It is specified via the version member function and can be any string. constexpr auto wget = Program ( \"wget\" , \"a non-interactive network retriever\" ) . version ( \"1.20.3\" ); In the automatic help, it is printed right next to the program name in the title line, so it is best to keep it within a maximum of ~16 characters. Output of the snippet above: wget 1.20.3 - a non-interactive network retriever Usage: wget [--help] Options & Flags: -h, --help Display this information","title":"version"},{"location":"user-guide/customization/#introduction","text":"introduction is what goes between the program name and its list of arguments. So, for example, it can be used as an actual introduction to the program and what is does, or some message about its usage. It is specified via the intro member function. Try to keep it short (2 or 3 lines maximum). constexpr auto wget = Program ( \"wget\" , \"a non-interactive network retriever\" ) . version ( \"1.20.3\" ) . intro ( \"Mandatory arguments to long options are mandatory for short options too.\" ); Output of the snippet above: wget 1.20.3 - a non-interactive network retriever Mandatory arguments to long options are mandatory for short options too. Usage: wget [--help] Options & Flags: -h, --help Display this information Just keep in mind that the introduction is used as a description for commands in the automatic help text of their parent program. In that case, an actual introduction is recommended. So an introduction like the example above is OK if the program is the root program.","title":"introduction"},{"location":"user-guide/customization/#details","text":"details is a piece of text that goes after the list of arguments. It can be used, for example, to add some details that weren't relevant before, like website, documentation, or contact information. It is specified via the details member function. constexpr auto wget = Program ( \"wget\" , \"a non-interactive network retriever\" ) . version ( \"1.20.3\" ) . intro ( \"Mandatory arguments to long options are mandatory for short options too.\" ) . details ( \"Email bug reports, questions, discussions to <bug-wget@gnu.org>\" \" and/or open issues at https://savannah.gnu.org/bugs/?func=additem&group=wget.\" ); Note that C++ allows strings to be break into separate pieces for better code formatting, but that does not affect the output of the automatic help. Don't make it too long, though, as that will move the argument list up in the help text. Output of the snippet above: wget 1.20.3 - a non-interactive network retriever Mandatory arguments to long options are mandatory for short options too. Usage: wget [--help] Options & Flags: -h, --help Display this information Email bug reports, questions, discussions to <bug-wget@gnu.org> and/or open issues at https://savannah.gnu.org/bugs/?func=additem&group=wget.","title":"details"},{"location":"user-guide/customization/#msg_width","text":"The msg_width is what determines the maximum width of the messages that opzioni will output related to the program. For example, it is used when printing the automatic help and when using the built-in error handling actions. The default is 100 and it can be changed via the max_width member function. constexpr auto wget = Program ( \"wget\" , \"a non-interactive network retriever\" ) . version ( \"1.20.3\" ) . intro ( \"Mandatory arguments to long options are mandatory for short options too.\" ) . details ( \"Email bug reports, questions, discussions to <bug-wget@gnu.org>\" \" and/or open issues at https://savannah.gnu.org/bugs/?func=additem&group=wget.\" ) . max_width ( 64 ); Output of the snippet above: wget 1.20.3 - a non-interactive network retriever Mandatory arguments to long options are mandatory for short options too. Usage: wget [--help] Options & Flags: -h, --help Display this information Email bug reports, questions, discussions to <bug-wget@gnu.org> and/or open issues at https://savannah.gnu.org/bugs/?func=additem&group=wget. It is a best-effort, though, so don't make it too narrow. If the maximum width is not enough for long words (like the URL above), they will be printed in a dedicated line anyway (try this last snippet with a maximum width of 32).","title":"msg_width"},{"location":"user-guide/customization/#error_handler","text":"error_handler determines how the program behaves when a user error occurs. This doesn't affect the automatic help text. The default is to print the error message and the usage of the program. Change it via the on_error member function. For example, to only print the error message: constexpr auto wget = Program ( \"wget\" , \"a non-interactive network retriever\" ) . version ( \"1.20.3\" ) . intro ( \"Mandatory arguments to long options are mandatory for short options too.\" ) . details ( \"Email bug reports, questions, discussions to <bug-wget@gnu.org>\" \" and/or open issues at https://savannah.gnu.org/bugs/?func=additem&group=wget.\" ) . max_width ( 64 ) . on_error ( print_error ); This also deserves a longer documentation, but until that's available, here is a brief explanation: The argument to on_error must be of the ErrorHandler type, which is actually a using declaration for the following function pointer: using ErrorHandler = int ( * )( ProgramView const , UserError const & ); ProgramView was introduced earlier . UserError is the base class of the exceptions that are thrown when a user error occurs (user as in user of the command-line program). All opzioni exceptions inherit from std::exception , so the error message can be obtained via their what member function. Currently, the built-in error handlers are: print_error : print the error message only. print_error_and_usage : print the error message and the program usage (the default). rethrow : rethrow the exception. Just a detail about rethrow : note that, given the signature of ErrorHandler , the information of the actual class of the exception that was thrown is lost. In order to preserve their type information (and also be able to granularly catch exceptions, if that's desired), use the parse free function instead of Program 's call operator when parsing the command-line. Just add a try and as many catch es as desired to the following snippet: auto const map = parse ( wget , { argv , argc }); argc and argv are \"flipped\" and within {} because that's constructing a std::span . Calling parse instead of Program::operator() avoids the built-in try... catch (which invokes error_handler ). This means that \"unsetting\" or clearing error_handler isn't needed. In fact, on_error(nullptr) or on_error(NULL) doesn't compile. error_handler is a required attribute of Program . snippet output generated by adding the automatic help to the example. \u21a9","title":"error_handler"},{"location":"user-guide/from-scratch/","text":"Starting from scratch \u00b6 This guide shows how to use opzioni right from the beginning: from #include -ing it to specifying the CLI and consuming the parsed values. As an example, we'll write a very simple curl . Include opzioni \u00b6 Including opzioni is as simple as include <opzioni.hpp> (or in quotes if building as an example ). For instance: #include <string_view> #include <fmt/format.h> #include \"opzioni.hpp\" int main ( int argc , char const * argv []) { using namespace opzioni ; } The using directive for the opzioni namespace is just to make things easier for now. You can always import the desired names individually later. Also, I'm using the awesome fmt library. You should check it out! Declare a program \u00b6 Now let's specify our CLI. First, declare a Program . constexpr auto curl = Program ( \"curl\" , \"transfer a URL\" ); This only creates a program named curl with a little title, so it doesn't do anything yet. Note that it is marked constexpr , so it means that curl is a constant expression , that is, its value is known at compile-time. Add arguments \u00b6 Let's add a positional argument for the URL, an option for the HTTP method, a flag for verbosity, and some help text. constexpr auto curl = Program ( \"curl\" , \"transfer a URL\" ) + Pos ( \"url\" ). help ( \"The URL to transfer\" ) * Opt ( \"request\" , \"X\" ). help ( \"The HTTP method to use\" ) * Flg ( \"verbose\" , \"v\" ). help ( \"Make the operation more talkative\" ) * Help (); Note that: a positional is created by calling the Pos() function with a name. Positionals are required by default. an option is created by calling the Opt() function with a name and an optional short name. Options are optional by default and have an empty string as default value. a flag is created by calling the Flg() function with a name and an optional short name. Flags are optional by default and have false as default value. Pos , Opt , and Flg are functions, not constructors. This is because the actual type of the arguments is Arg and it represents any type of argument. If its constructor were to be called, the type would have to be specified, requiring more typing. So these functions exist as helpers (or factories) for the supported kinds: positional, option, and flag. the .help() member function is how descriptions are added to arguments. They will appear in the automatic help text. calling Help() adds a help flag that handles the automatic help text. It is just a shorthand for this very common flag, so there's nothing special about it. Here how it's done: Flg ( \"help\" , \"h\" ). help ( description ). action ( actions :: print_help ); Where description is \"Display this information\" by default. there is a * between every pair of arguments. This creates an array of arguments at compile-time to be added to the Program . there is a + between the Program and the arguments. This adds the array of arguments to the Program at compile-time . There are way more features available (see Customization ), but we'll keep things simple for now. Parse the CLI \u00b6 We just need to call curl with argc and argv . As simple as that! auto const map = curl ( argc , argv ); The result is a map of arguments of what was parsed from the CLI. Note that map is not constexpr , since its value depends on runtime information. Automatic error handling is provided when calling the call operator of Program . This means that, if the user gives curl some invalid arguments, the default behavior is to terminate the program and show an error message alongside the usage of the program. This is explained later, but this behavior can be changed either while keeping the automatic error handling or not. Get the results \u00b6 There are a few ways of getting the results out of the map: std :: string_view const url = map [ \"url\" ]; // 1 auto const url = map . as < std :: string_view > ( \"url\" ); // 2 auto const url = map [ \"url\" ]. as < std :: string_view > (); // 3 Choose whichever you like most. However, it is always the long name of the argument that is used to get the result from the map. So, for example, to get the value of the request option, it's always via the name request , never X . Now let's print them out! std :: string_view const url = map [ \"url\" ]; std :: string_view const request = map [ \"request\" ]; bool const verbose = map [ \"verbose\" ]; fmt :: print ( \"url: {} \\n \" , url ); fmt :: print ( \"request: {} \\n \" , request ); fmt :: print ( \"verbose: {} \\n \" , verbose ); Full C++ code \u00b6 #include <string_view> #include <fmt/format.h> #include \"opzioni.hpp\" int main ( int argc , char const * argv []) { using namespace opzioni ; constexpr auto curl = Program ( \"curl\" , \"transfer a URL\" ) + Pos ( \"url\" ). help ( \"The URL to transfer\" ) * Opt ( \"request\" , \"X\" ). help ( \"The HTTP method to use\" ) * Flg ( \"verbose\" , \"v\" ). help ( \"Make the operation more talkative\" ) * Help (); auto const map = curl ( argc , argv ); std :: string_view const url = map [ \"url\" ]; std :: string_view const request = map [ \"request\" ]; bool const verbose = map [ \"verbose\" ]; fmt :: print ( \"url: {} \\n \" , url ); fmt :: print ( \"request: {} \\n \" , request ); fmt :: print ( \"verbose: {} \\n \" , verbose ); } Build as an example \u00b6 Put the newly created file in the examples/ directory, say, curl.cpp . Add an executable entry for it in examples/meson.build , just like the other examples. curl = executable ( 'curl' , 'curl.cpp' , dependencies : [ fmt_dep , opzioni_dep ] ) Run make build Test your new CLI! See the automatic help: ./build/examples/curl --help Test that URL is really required by giving no arguments to the executable: ./build/examples/curl Give it a valid set of arguments and see the output: ./build/examples/curl -X GET google.com","title":"Starting from scratch"},{"location":"user-guide/from-scratch/#starting-from-scratch","text":"This guide shows how to use opzioni right from the beginning: from #include -ing it to specifying the CLI and consuming the parsed values. As an example, we'll write a very simple curl .","title":"Starting from scratch"},{"location":"user-guide/from-scratch/#include-opzioni","text":"Including opzioni is as simple as include <opzioni.hpp> (or in quotes if building as an example ). For instance: #include <string_view> #include <fmt/format.h> #include \"opzioni.hpp\" int main ( int argc , char const * argv []) { using namespace opzioni ; } The using directive for the opzioni namespace is just to make things easier for now. You can always import the desired names individually later. Also, I'm using the awesome fmt library. You should check it out!","title":"Include opzioni"},{"location":"user-guide/from-scratch/#declare-a-program","text":"Now let's specify our CLI. First, declare a Program . constexpr auto curl = Program ( \"curl\" , \"transfer a URL\" ); This only creates a program named curl with a little title, so it doesn't do anything yet. Note that it is marked constexpr , so it means that curl is a constant expression , that is, its value is known at compile-time.","title":"Declare a program"},{"location":"user-guide/from-scratch/#add-arguments","text":"Let's add a positional argument for the URL, an option for the HTTP method, a flag for verbosity, and some help text. constexpr auto curl = Program ( \"curl\" , \"transfer a URL\" ) + Pos ( \"url\" ). help ( \"The URL to transfer\" ) * Opt ( \"request\" , \"X\" ). help ( \"The HTTP method to use\" ) * Flg ( \"verbose\" , \"v\" ). help ( \"Make the operation more talkative\" ) * Help (); Note that: a positional is created by calling the Pos() function with a name. Positionals are required by default. an option is created by calling the Opt() function with a name and an optional short name. Options are optional by default and have an empty string as default value. a flag is created by calling the Flg() function with a name and an optional short name. Flags are optional by default and have false as default value. Pos , Opt , and Flg are functions, not constructors. This is because the actual type of the arguments is Arg and it represents any type of argument. If its constructor were to be called, the type would have to be specified, requiring more typing. So these functions exist as helpers (or factories) for the supported kinds: positional, option, and flag. the .help() member function is how descriptions are added to arguments. They will appear in the automatic help text. calling Help() adds a help flag that handles the automatic help text. It is just a shorthand for this very common flag, so there's nothing special about it. Here how it's done: Flg ( \"help\" , \"h\" ). help ( description ). action ( actions :: print_help ); Where description is \"Display this information\" by default. there is a * between every pair of arguments. This creates an array of arguments at compile-time to be added to the Program . there is a + between the Program and the arguments. This adds the array of arguments to the Program at compile-time . There are way more features available (see Customization ), but we'll keep things simple for now.","title":"Add arguments"},{"location":"user-guide/from-scratch/#parse-the-cli","text":"We just need to call curl with argc and argv . As simple as that! auto const map = curl ( argc , argv ); The result is a map of arguments of what was parsed from the CLI. Note that map is not constexpr , since its value depends on runtime information. Automatic error handling is provided when calling the call operator of Program . This means that, if the user gives curl some invalid arguments, the default behavior is to terminate the program and show an error message alongside the usage of the program. This is explained later, but this behavior can be changed either while keeping the automatic error handling or not.","title":"Parse the CLI"},{"location":"user-guide/from-scratch/#get-the-results","text":"There are a few ways of getting the results out of the map: std :: string_view const url = map [ \"url\" ]; // 1 auto const url = map . as < std :: string_view > ( \"url\" ); // 2 auto const url = map [ \"url\" ]. as < std :: string_view > (); // 3 Choose whichever you like most. However, it is always the long name of the argument that is used to get the result from the map. So, for example, to get the value of the request option, it's always via the name request , never X . Now let's print them out! std :: string_view const url = map [ \"url\" ]; std :: string_view const request = map [ \"request\" ]; bool const verbose = map [ \"verbose\" ]; fmt :: print ( \"url: {} \\n \" , url ); fmt :: print ( \"request: {} \\n \" , request ); fmt :: print ( \"verbose: {} \\n \" , verbose );","title":"Get the results"},{"location":"user-guide/from-scratch/#full-c-code","text":"#include <string_view> #include <fmt/format.h> #include \"opzioni.hpp\" int main ( int argc , char const * argv []) { using namespace opzioni ; constexpr auto curl = Program ( \"curl\" , \"transfer a URL\" ) + Pos ( \"url\" ). help ( \"The URL to transfer\" ) * Opt ( \"request\" , \"X\" ). help ( \"The HTTP method to use\" ) * Flg ( \"verbose\" , \"v\" ). help ( \"Make the operation more talkative\" ) * Help (); auto const map = curl ( argc , argv ); std :: string_view const url = map [ \"url\" ]; std :: string_view const request = map [ \"request\" ]; bool const verbose = map [ \"verbose\" ]; fmt :: print ( \"url: {} \\n \" , url ); fmt :: print ( \"request: {} \\n \" , request ); fmt :: print ( \"verbose: {} \\n \" , verbose ); }","title":"Full C++ code"},{"location":"user-guide/from-scratch/#build-as-an-example","text":"Put the newly created file in the examples/ directory, say, curl.cpp . Add an executable entry for it in examples/meson.build , just like the other examples. curl = executable ( 'curl' , 'curl.cpp' , dependencies : [ fmt_dep , opzioni_dep ] ) Run make build Test your new CLI! See the automatic help: ./build/examples/curl --help Test that URL is really required by giving no arguments to the executable: ./build/examples/curl Give it a valid set of arguments and see the output: ./build/examples/curl -X GET google.com","title":"Build as an example"},{"location":"user-guide/running-with-docker/","text":"Running with Docker \u00b6 Since opzioni is not available in any package repository yet, this guide will cover trying it out with Docker, just like I do during development. First, make sure you have Docker and Docker Compose installed. Instructions for installing Docker can be found here (just select your OS) and for Compose here . If you're a VS Code user, you may want to install the Remote Development extension pack (ID ms-vscode-remote.vscode-remote-extensionpack ) to open the container in VS Code. Clone the repo. git clone https://github.com/ggabriel96/opzioni.git Run the container. If on VS Code, hit Ctrl + Shift + P and select the option Remote-Containers: Reopen in Container . If not on VS Code, you still might be able to open the project inside the container (e.g. with CLion), it just happens that I don't have a license and hence haven't tried it. If running the container through an IDE is not desired, you may open a terminal, navigate to the project, and run: docker build -f .devcontainer/Dockerfile -t opzioni . docker run --rm -it -v $( pwd ) :/home/conan/opzioni:Z -w /home/conan/opzioni/ opzioni The :Z option is unnecessary if not using SELinux. Having built and run the container from the terminal, you may edit any file from outside the container as usual. Once inside the container, run make . This will fetch the dependencies with Conan and build the whole project with Meson, including the examples and unit tests. run make build for additional builds run make test to run the unit tests run make format to format the code with ClangFormat run make clean to clean everything (after this, another full make is needed) You're done! The compiled examples will be in build/examples/ . For example, to run the main example: ./build/examples/main --help","title":"Running with Docker"},{"location":"user-guide/running-with-docker/#running-with-docker","text":"Since opzioni is not available in any package repository yet, this guide will cover trying it out with Docker, just like I do during development. First, make sure you have Docker and Docker Compose installed. Instructions for installing Docker can be found here (just select your OS) and for Compose here . If you're a VS Code user, you may want to install the Remote Development extension pack (ID ms-vscode-remote.vscode-remote-extensionpack ) to open the container in VS Code. Clone the repo. git clone https://github.com/ggabriel96/opzioni.git Run the container. If on VS Code, hit Ctrl + Shift + P and select the option Remote-Containers: Reopen in Container . If not on VS Code, you still might be able to open the project inside the container (e.g. with CLion), it just happens that I don't have a license and hence haven't tried it. If running the container through an IDE is not desired, you may open a terminal, navigate to the project, and run: docker build -f .devcontainer/Dockerfile -t opzioni . docker run --rm -it -v $( pwd ) :/home/conan/opzioni:Z -w /home/conan/opzioni/ opzioni The :Z option is unnecessary if not using SELinux. Having built and run the container from the terminal, you may edit any file from outside the container as usual. Once inside the container, run make . This will fetch the dependencies with Conan and build the whole project with Meson, including the examples and unit tests. run make build for additional builds run make test to run the unit tests run make format to format the code with ClangFormat run make clean to clean everything (after this, another full make is needed) You're done! The compiled examples will be in build/examples/ . For example, to run the main example: ./build/examples/main --help","title":"Running with Docker"}]}