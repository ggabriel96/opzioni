{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 opzioni is a command line arguments parser library for C++. Goals \u00b6 The goals of this library, in order of importance, are: Be as simple and enjoyable as possible. This mainly targets the user of the library, but also includes the user of the command line tool built with it. constexpr -all-the-things. Most of the time, all the information needed to build a command line interface is available at compile-time, so we should take advantage of that. If it compiles, it works. That's utopic, but that's what is being strived for. It's also very closely related to the previous goal. We should be able to detect most errors at compile-time and provide decent diagnostics. Try not to repeat yourself. When specifying a CLI, if some information was already given to the library, that same information should not be needed again. For example, if the type of an argument was already specified, the user should not be asked to tell the type again. Unfortunately that is very hard, so some places still require duplicate information. Be bleeding-edge. This library requires C++20. That limits a lot its potential users, but also allows for the use of the new and powerful features of C++. It also helps to accomplish the previous goals. Disclaimer \u00b6 This is a personal project with no promise of maintainability for the time being. I started it to learn more about C++ and its new features. Although it is not in early development, since I'm working on it for months and iterated over it many times, it is not stable or production-ready . There are many unit tests missing . I frequently changed the interface of the library and I'm not afraid of changing it radically again if I think it would improve the UX. Another example is the names of the namespaces and what is in them. There is a lot of polish and optimization work to do. There is a whole documentation to write. Sneak peek \u00b6 The code below is a fully working example, taken from examples/hello.cpp , only reformatted and with quotes changed to angle brackets in the #include . Feel free to take a look at the other, more complex, examples in the same directory. #include <iostream> #include <string_view> #include <opzioni.hpp> int main ( int argc , char const * argv []) { using namespace opzioni ; constexpr auto hello = Program ( \"hello\" ). version ( \"0.1\" ). intro ( \"Greeting people since the dawn of computing\" ) + Help () * Version () * Pos ( \"name\" ). help ( \"Your name please, so I can greet you\" ); auto const args = hello ( argc , argv ); std :: string_view const name = args [ \"name\" ]; std :: cout << \"Hello, \" << name << \"! \\n \" ; } That gives us: Automatic help with --help or -h $ ./build/examples/hello -h hello 0.1 Greeting people since the dawn of computing Usage: hello <name> [--help] [--version] Positionals: name Your name please, so I can greet you Options & Flags: -h, --help Display this information -V, --version Display the software version Automatic version with --version or -V $ ./build/examples/hello -V hello 0 .1 Automatic error handling $ ./build/examples/hello Gabriel Galli Unexpected positional argument `Galli`. This program expects 1 positional arguments Usage: hello <name> [--help] [--version] And finally: $ ./build/examples/hello \"Gabriel Galli\" Hello, Gabriel Galli! Getting started \u00b6 opzioni is not published anywhere yet. The goal is to eventually make it available on: Conan vcpkg Meson's Wrap DB conda-forge Spack Meanwhile, there are a few options to build and try it out. See the TLDR below. TLDR \u00b6 There are few options to get up to speed on building opzioni: If you're familiar with Docker, there is a Dockerfile and a docker-compose.yml in .devcontainer/ . Also, the project is already configured to work with VS Code Remote Containers . If you're familiar with NixOS , there is a shell.nix ready to use. Once in your chosen environment, simply run make . That should download the build dependencies with Conan and build the whole project with Meson and ninja. The Makefile is just a simple helper to avoid having to remember all the commands. Dependencies \u00b6 All dependencies below might still work if on earlier minor versions, but I'm not sure. I still gotta pin them (except for fmt and Catch2 , which are somewhat pinned in the build definitions). I always try to go for the latest versions. GCC >= 10.2. Concepts and Ranges support is required. meson >= 0.50 (gotta check that) ninja >= 1.10 fmt >= 7.0.3 Catch2 >= 2.13.0 ClangFormat 10 if willing to apply the formatting as checked in CI License \u00b6 opzioni's license is the Boost Software License (BSL) 1.0 . This means you are free to use this library as you wish and see fit. It is only needed to provide a copy of the license if the source is also being distributed. In other words, there is no need to bundle opzioni's license with your binary .","title":"Home"},{"location":"#home","text":"opzioni is a command line arguments parser library for C++.","title":"Home"},{"location":"#goals","text":"The goals of this library, in order of importance, are: Be as simple and enjoyable as possible. This mainly targets the user of the library, but also includes the user of the command line tool built with it. constexpr -all-the-things. Most of the time, all the information needed to build a command line interface is available at compile-time, so we should take advantage of that. If it compiles, it works. That's utopic, but that's what is being strived for. It's also very closely related to the previous goal. We should be able to detect most errors at compile-time and provide decent diagnostics. Try not to repeat yourself. When specifying a CLI, if some information was already given to the library, that same information should not be needed again. For example, if the type of an argument was already specified, the user should not be asked to tell the type again. Unfortunately that is very hard, so some places still require duplicate information. Be bleeding-edge. This library requires C++20. That limits a lot its potential users, but also allows for the use of the new and powerful features of C++. It also helps to accomplish the previous goals.","title":"Goals"},{"location":"#disclaimer","text":"This is a personal project with no promise of maintainability for the time being. I started it to learn more about C++ and its new features. Although it is not in early development, since I'm working on it for months and iterated over it many times, it is not stable or production-ready . There are many unit tests missing . I frequently changed the interface of the library and I'm not afraid of changing it radically again if I think it would improve the UX. Another example is the names of the namespaces and what is in them. There is a lot of polish and optimization work to do. There is a whole documentation to write.","title":"Disclaimer"},{"location":"#sneak-peek","text":"The code below is a fully working example, taken from examples/hello.cpp , only reformatted and with quotes changed to angle brackets in the #include . Feel free to take a look at the other, more complex, examples in the same directory. #include <iostream> #include <string_view> #include <opzioni.hpp> int main ( int argc , char const * argv []) { using namespace opzioni ; constexpr auto hello = Program ( \"hello\" ). version ( \"0.1\" ). intro ( \"Greeting people since the dawn of computing\" ) + Help () * Version () * Pos ( \"name\" ). help ( \"Your name please, so I can greet you\" ); auto const args = hello ( argc , argv ); std :: string_view const name = args [ \"name\" ]; std :: cout << \"Hello, \" << name << \"! \\n \" ; } That gives us: Automatic help with --help or -h $ ./build/examples/hello -h hello 0.1 Greeting people since the dawn of computing Usage: hello <name> [--help] [--version] Positionals: name Your name please, so I can greet you Options & Flags: -h, --help Display this information -V, --version Display the software version Automatic version with --version or -V $ ./build/examples/hello -V hello 0 .1 Automatic error handling $ ./build/examples/hello Gabriel Galli Unexpected positional argument `Galli`. This program expects 1 positional arguments Usage: hello <name> [--help] [--version] And finally: $ ./build/examples/hello \"Gabriel Galli\" Hello, Gabriel Galli!","title":"Sneak peek"},{"location":"#getting-started","text":"opzioni is not published anywhere yet. The goal is to eventually make it available on: Conan vcpkg Meson's Wrap DB conda-forge Spack Meanwhile, there are a few options to build and try it out. See the TLDR below.","title":"Getting started"},{"location":"#tldr","text":"There are few options to get up to speed on building opzioni: If you're familiar with Docker, there is a Dockerfile and a docker-compose.yml in .devcontainer/ . Also, the project is already configured to work with VS Code Remote Containers . If you're familiar with NixOS , there is a shell.nix ready to use. Once in your chosen environment, simply run make . That should download the build dependencies with Conan and build the whole project with Meson and ninja. The Makefile is just a simple helper to avoid having to remember all the commands.","title":"TLDR"},{"location":"#dependencies","text":"All dependencies below might still work if on earlier minor versions, but I'm not sure. I still gotta pin them (except for fmt and Catch2 , which are somewhat pinned in the build definitions). I always try to go for the latest versions. GCC >= 10.2. Concepts and Ranges support is required. meson >= 0.50 (gotta check that) ninja >= 1.10 fmt >= 7.0.3 Catch2 >= 2.13.0 ClangFormat 10 if willing to apply the formatting as checked in CI","title":"Dependencies"},{"location":"#license","text":"opzioni's license is the Boost Software License (BSL) 1.0 . This means you are free to use this library as you wish and see fit. It is only needed to provide a copy of the license if the source is also being distributed. In other words, there is no need to bundle opzioni's license with your binary .","title":"License"},{"location":"user-guide/","text":"User guide \u00b6 Running with Docker \u00b6 Since opzioni is not available in any package repository yet, this guide will cover trying it out with Docker, just like I do during development. First, make sure you have Docker and Docker Compose installed. Instructions for installing Docker can be found here (just select your OS) and for Compose here . If you're a VS Code user, you may want to install the Remote Development extension pack (ID ms-vscode-remote.vscode-remote-extensionpack ) to open the container in VS Code. Clone the repo. git clone https://github.com/ggabriel96/opzioni.git Run the container. If on VS Code, hit Ctrl + Shift + P and select the option Remote-Containers: Reopen in Container . If not on VS Code, you still might be able to open the project inside the container (e.g. with CLion), it just happens that I don't have a license and hence haven't tried it. If running the container through an IDE is not desired, you may open a terminal, navigate to the project, and run: docker build -f .devcontainer/Dockerfile -t opzioni . docker run --rm -it -v $( pwd ) :/home/conan/opzioni:Z -w /home/conan/opzioni/ opzioni The :Z option is unnecessary if not using SELinux. Having built and run the container from the terminal, you may edit any file from outside the container as usual. Once inside the container, run make . This will fetch the dependencies with Conan and build the whole project with Meson, including the examples and unit tests. run make build for additional builds run make test to run the unit tests run make format to format the code with ClangFormat run make clean to clean everything (after this, another full make is needed) You're done! The compiled examples will be in build/examples/ . For example, to run the main example: ./build/examples/main --help Writing a new CLI from scratch \u00b6 Let's start a very simple curl . Create a new file in the examples/ directory, say, curl.cpp . Import opzioni and any other libraries you might want to use. Then add a main . For example: #include <string_view> // the awesome fmt library is installed and available! #include <fmt/format.h> #include \"opzioni.hpp\" int main ( int argc , char const * argv []) { using namespace opzioni ; } The using directive for the opzioni namespace is just to make things easier for now. You can always import the desired names individually later. Now let's specify our CLI. First, declare a Program . constexpr auto curl = Program ( \"curl\" ). intro ( \"transfer a URL\" ); This only creates a program named curl with a little introduction, so it doesn't do anything yet. Add arguments to the program. Let's add a positional argument for the URL, an option for the HTTP method, and a help flag. constexpr auto curl = Program ( \"curl\" ). intro ( \"transfer a URL\" ) + Pos ( \"url\" ). help ( \"The URL to transfer\" ) * Opt ( \"request\" , \"X\" ). help ( \"The HTTP method to use\" ) * Help (); Note that: a positional is created by calling Pos() with a name. Positionals are required by default. an option is created by calling Opt() with a name and an optional short name. Options are optional by default and have an empty string as default value. the automatic help text is created by calling Help() . It is a flag and, being so, is also optional by default. the .help() member function is how descriptions are added to arguments. They will appear in the automatic help text. there is a * between every pair of arguments. This creates an array of arguments to be added to the Program . there is a + between the Program and the arguments. This will add the array of arguments to the Program . Parse the CLI. We just need to call curl with argc and argv . As simple as that! auto const map = curl ( argc , argv ); The result is a map of arguments of what was parsed from the CLI. Print the results. There are a few ways of getting the results out of the map: std :: string_view const url = map [ \"url\" ]; // 1 auto const url = map . as < std :: string_view > ( \"url\" ); // 2 auto const url = map [ \"url\" ]. as < std :: string_view > (); // 3 Choose whichever you like most. However, it is always the long name of the argument that is used to get the result from the map. Now let's print them out! std :: string_view const url = map [ \"url\" ]; std :: string_view const request = map [ \"request\" ]; fmt :: print ( \"url: {} \\n \" , url ); fmt :: print ( \"request: {} \\n \" , request ); And that's it! Now let's build the CLI and give it a try! Add an executable entry for it in examples/meson.build , just like the other examples. curl = executable ( 'curl' , 'curl.cpp' , dependencies : [ fmt_dep , opzioni_dep ] ) Run make build Test your new CLI! See the automatic help: ./build/examples/curl --help Test that URL is really required by giving no arguments to the executable: ./build/examples/curl Give it all arguments and see the output: ./build/examples/curl -X GET google.com Just for convenience, here is the full C++ code: #include <string_view> #include <fmt/format.h> #include \"opzioni.hpp\" int main ( int argc , char const * argv []) { using namespace opzioni ; constexpr auto curl = Program ( \"curl\" ). intro ( \"transfer a URL\" ) + Pos ( \"url\" ). help ( \"The URL to transfer\" ) * Opt ( \"request\" , \"X\" ). help ( \"The HTTP method to use\" ) * Help (); auto const map = curl ( argc , argv ); std :: string_view const url = map [ \"url\" ]; std :: string_view const request = map [ \"request\" ]; fmt :: print ( \"url: {} \\n \" , url ); fmt :: print ( \"request: {} \\n \" , request ); }","title":"User guide"},{"location":"user-guide/#user-guide","text":"","title":"User guide"},{"location":"user-guide/#running-with-docker","text":"Since opzioni is not available in any package repository yet, this guide will cover trying it out with Docker, just like I do during development. First, make sure you have Docker and Docker Compose installed. Instructions for installing Docker can be found here (just select your OS) and for Compose here . If you're a VS Code user, you may want to install the Remote Development extension pack (ID ms-vscode-remote.vscode-remote-extensionpack ) to open the container in VS Code. Clone the repo. git clone https://github.com/ggabriel96/opzioni.git Run the container. If on VS Code, hit Ctrl + Shift + P and select the option Remote-Containers: Reopen in Container . If not on VS Code, you still might be able to open the project inside the container (e.g. with CLion), it just happens that I don't have a license and hence haven't tried it. If running the container through an IDE is not desired, you may open a terminal, navigate to the project, and run: docker build -f .devcontainer/Dockerfile -t opzioni . docker run --rm -it -v $( pwd ) :/home/conan/opzioni:Z -w /home/conan/opzioni/ opzioni The :Z option is unnecessary if not using SELinux. Having built and run the container from the terminal, you may edit any file from outside the container as usual. Once inside the container, run make . This will fetch the dependencies with Conan and build the whole project with Meson, including the examples and unit tests. run make build for additional builds run make test to run the unit tests run make format to format the code with ClangFormat run make clean to clean everything (after this, another full make is needed) You're done! The compiled examples will be in build/examples/ . For example, to run the main example: ./build/examples/main --help","title":"Running with Docker"},{"location":"user-guide/#writing-a-new-cli-from-scratch","text":"Let's start a very simple curl . Create a new file in the examples/ directory, say, curl.cpp . Import opzioni and any other libraries you might want to use. Then add a main . For example: #include <string_view> // the awesome fmt library is installed and available! #include <fmt/format.h> #include \"opzioni.hpp\" int main ( int argc , char const * argv []) { using namespace opzioni ; } The using directive for the opzioni namespace is just to make things easier for now. You can always import the desired names individually later. Now let's specify our CLI. First, declare a Program . constexpr auto curl = Program ( \"curl\" ). intro ( \"transfer a URL\" ); This only creates a program named curl with a little introduction, so it doesn't do anything yet. Add arguments to the program. Let's add a positional argument for the URL, an option for the HTTP method, and a help flag. constexpr auto curl = Program ( \"curl\" ). intro ( \"transfer a URL\" ) + Pos ( \"url\" ). help ( \"The URL to transfer\" ) * Opt ( \"request\" , \"X\" ). help ( \"The HTTP method to use\" ) * Help (); Note that: a positional is created by calling Pos() with a name. Positionals are required by default. an option is created by calling Opt() with a name and an optional short name. Options are optional by default and have an empty string as default value. the automatic help text is created by calling Help() . It is a flag and, being so, is also optional by default. the .help() member function is how descriptions are added to arguments. They will appear in the automatic help text. there is a * between every pair of arguments. This creates an array of arguments to be added to the Program . there is a + between the Program and the arguments. This will add the array of arguments to the Program . Parse the CLI. We just need to call curl with argc and argv . As simple as that! auto const map = curl ( argc , argv ); The result is a map of arguments of what was parsed from the CLI. Print the results. There are a few ways of getting the results out of the map: std :: string_view const url = map [ \"url\" ]; // 1 auto const url = map . as < std :: string_view > ( \"url\" ); // 2 auto const url = map [ \"url\" ]. as < std :: string_view > (); // 3 Choose whichever you like most. However, it is always the long name of the argument that is used to get the result from the map. Now let's print them out! std :: string_view const url = map [ \"url\" ]; std :: string_view const request = map [ \"request\" ]; fmt :: print ( \"url: {} \\n \" , url ); fmt :: print ( \"request: {} \\n \" , request ); And that's it! Now let's build the CLI and give it a try! Add an executable entry for it in examples/meson.build , just like the other examples. curl = executable ( 'curl' , 'curl.cpp' , dependencies : [ fmt_dep , opzioni_dep ] ) Run make build Test your new CLI! See the automatic help: ./build/examples/curl --help Test that URL is really required by giving no arguments to the executable: ./build/examples/curl Give it all arguments and see the output: ./build/examples/curl -X GET google.com Just for convenience, here is the full C++ code: #include <string_view> #include <fmt/format.h> #include \"opzioni.hpp\" int main ( int argc , char const * argv []) { using namespace opzioni ; constexpr auto curl = Program ( \"curl\" ). intro ( \"transfer a URL\" ) + Pos ( \"url\" ). help ( \"The URL to transfer\" ) * Opt ( \"request\" , \"X\" ). help ( \"The HTTP method to use\" ) * Help (); auto const map = curl ( argc , argv ); std :: string_view const url = map [ \"url\" ]; std :: string_view const request = map [ \"request\" ]; fmt :: print ( \"url: {} \\n \" , url ); fmt :: print ( \"request: {} \\n \" , request ); }","title":"Writing a new CLI from scratch"}]}